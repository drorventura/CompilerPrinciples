package adtl;

import java_cup.runtime.*;
import java.util.*;
import adtl.Lexer.*;
import adtl.ast.*;

parser code {:
    public void syntax_error(java_cup.runtime.Symbol current) {
        Token t = (Token) current;
        throw new SyntaxError("Syntax error in line " + t.line + " '" + t.toText() + "'");
    }
:};

/* Terminals (tokens returned by the scanner). */
terminal                    REV, ASSERT, CHOOSE, IN, LOCK, IF, RETURN, NEW, ELSE, SET;
terminal                    LCBR, SEMI, LT, LP, COMMA, RP, DOT, RCBR, COLON, AT;
terminal                    DIVIDE, LTE, MINUS, BAR, NOT, PLUS, ASSIGN, LAND, ASSIGN_PLUS, LOR, NEQ, ASSIGN_MINUS, EQ, GTE, TIMES, GT;
terminal                    UMINUS;
terminal String             ID, QUOTE;
terminal Integer            INT;

/* Non terminals */
non terminal ADT            ADT;
non terminal ElementList    ElementList;
non terminal Element        Element;
non terminal FieldDef       FieldDef;
non terminal Type           Type;
non terminal MethodDef      MethodDef;
non terminal                ArgPart;
non terminal Args           Arg;
non terminal StmtList       StmtList;
non terminal Stmt           Stmt;
non terminal Assign         Assign;
non terminal Expr           Expr;
non terminal                AssignedArgPart;
non terminal AssignedArgs   AssignedArg;
non terminal PathExpr       PathExpr;
non terminal PathElement    PathElement;
non terminal                SingleOrBlockStmt;


/* Precedences */
precedence left ELSE;
precedence left LOR, LAND;
precedence nonassoc NOT, LT, LTE, GT, GTE, EQ, NEQ;
precedence left PLUS, MINUS;
precedence left TIMES, DIVIDE;
precedence left UMINUS;
precedence nonassoc IN;


/* The grammar */
ADT                 ::= ID:name LCBR  ElementList:list RCBR
                        /*{: RESULT = new ADT(name, list); :}*/
                        ;

ElementList         ::= ElementList Element
                        |
                        Element
                        ;

Element             ::= FieldDef
                        |
                        MethodDef
                        ;

FieldDef            ::= ID:name COLON Type:type SEMI;

Type                ::= ID:name
                        |
                        SET
                        ;

MethodDef           ::= ID:name LP ArgPart RP LCBR StmtList RCBR
                        |
                        ID:name LP ArgPart RP LCBR RCBR
                        |
                        ID:name LP RP LCBR StmtList RCBR
                        |
                        ID:name LP RP LCBR RCBR
                        ;

ArgPart             ::= Arg COMMA ArgPart
                        |
                        Arg
                        ;

Arg                 ::= ID:name COLON Type;

StmtList            ::= StmtList Stmt
                        |
                        Stmt
                        ;

Stmt                ::= RETURN Expr SEMI
                        |
                        Assign SEMI
                        |
                        IF LP Expr RP SingleOrBlockStmt
                        |
                        IF LP Expr RP SingleOrBlockStmt ELSE SingleOrBlockStmt
                        |
                        ASSERT Expr SEMI
                        |
                        ASSERT Expr COLON QUOTE SEMI
                        |
                        LOCK PathExpr SEMI
                        ;

Assign              ::= PathExpr ASSIGN_PLUS Expr
                        |
                        PathExpr ASSIGN_MINUS Expr
                        |
                        PathExpr ASSIGN Expr
                        ;

SingleOrBlockStmt   ::= Stmt
                        |
                        LCBR StmtList RCBR
                        ;

Expr                ::= CHOOSE:sym_num Expr:expr /**************************************************/
                        {: RESULT = new ExprList();
                           RESULT.append(new Expr(sym_num));
                           RESULT.append(expr)
                        :}
                        |
                        INT:value
                        {: RESULT = new Integer(value); :}
                        |
                        BAR Expr:expr BAR
                        {: RESULT = new Size(expr); :}
                        |
                        NEW Type:type LP AssignedArgPart:args RP
                        {: RESULT = new NewExpr(type,args); :}
                        |
                        MINUS Expr:expr
                        {: RESULT = new Integer(0 - expr.intValue()); :}
                        %prec UMINUS
                        |
                        Expr:expr_lhs PLUS:op Expr:expr_rhs
                        {: RESULT = new BinaryExpr(op,expr_lhs,expr_rhs) :}
                        |
                        Expr:expr_lhs TIMES:op Expr:expr_rhs
                        {: RESULT = new BinaryExpr(op,expr_lhs,expr_rhs) :}
                        |
                        Expr:expr_lhs MINUS:op Expr:expr_rhs
                        {: RESULT = new BinaryExpr(op,expr_lhs,expr_rhs) :}
                        |
                        Expr:expr_lhs DIVIDE:op Expr:expr_rhs
                        {: RESULT = new BinaryExpr(op,expr_lhs,expr_rhs) :}
                        |
                        Expr:expr_lhs LT:op Expr:expr_rhs
                        {: RESULT = new BinaryExpr(op,expr_lhs,expr_rhs) :}
                        |
                        Expr:expr_lhs LTE:op Expr:expr_rhs
                        {: RESULT = new BinaryExpr(op,expr_lhs,expr_rhs) :}
                        |
                        Expr:expr_lhs GT:op Expr:expr_rhs
                        {: RESULT = new BinaryExpr(op,expr_lhs,expr_rhs) :}
                        |
                        Expr:expr_lhs GTE:op Expr:expr_rhs
                        {: RESULT = new BinaryExpr(op,expr_lhs,expr_rhs) :}
                        |
                        Expr:expr_lhs EQ:op Expr:expr_rhs
                        {: RESULT = new BinaryExpr(op,expr_lhs,expr_rhs) :}
                        |
                        Expr:expr_lhs NEQ:op Expr:expr_rhs
                        {: RESULT = new BinaryExpr(op,expr_lhs,expr_rhs) :}
                        |
                        NOT Expr
                        |
                        Expr:expr_lhs LAND:op Expr:expr_rhs
                        {: RESULT = new BinaryExpr(op,expr_lhs,expr_rhs) :}
                        |
                        Expr:expr_lhs LOR:op Expr:expr_rhs
                        {: RESULT = new BinaryExpr(op,expr_lhs,expr_rhs) :}
                        |
                        Expr IN Expr
                        |
                        PathExpr
                        |
                        LP Expr RP
                        ;

AssignedArgPart     ::= AssignedArg COMMA AssignedArgPart
                        |
                        AssignedArg
                        ;

AssignedArg         ::= ID:arg ASSIGN Expr:val
                        {: RESULT = new AssignedArgs(arg,val); :}
                        ;

PathExpr            ::= PathElement:pathElement DOT PathExpr:pathExpr
                        {: RESULT = ( pathExpr.append(pathElement) ); :}
                        |
                        PathElement:pathElement
                        {: RESULT = new PathExpr(pathElement); :}
                        ;

PathElement         ::= ID:name
                        {: RESULT = new PathElement(name,false,false); :}
                        |
                        ID:name AT
                        {: RESULT = new PathElement(name,false,true); :}
                        |
                        REV LP ID:name RP
                        {: RESULT = new PathElement(name, true, false); :}
                        |
                        REV LP ID:name RP AT
                        {: RESULT = new PathElement(name, true, true); :}
                        ;